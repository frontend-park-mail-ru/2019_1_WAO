package main

// массив с блоками, изначально пустой
var blocks = [];

type Block struct {
	w int
	h int
	x float
	y float
}

var blocks []Block
// позже задействуем, тут будет храниться расстояние между последним и новым блоком
dy2 := false;

// а вот и функция createBlock для создания одного бока (добавляет его после последнего)
func createBlock() {
	if !dy2 { // если последний блок еще не был определен, установим начальную позицию для первого блока
		dy2 = height - 60*del*4; // расположим его почти внизу экрана
	} else { // если же позиция имеется, прибавляем к ней рандомно половину высоты прыжка (получено экспериментально)
		dy2 = blocks[blocks.length-1].y - 500*del -
					math.random(500*del, 800*del); // а вот и рандом
	}
	blocks.push(game.newImageObject({ // пушим новый блок в массив
		w : 200 * del*4, h : 60 * del*4, // размеры
		// file : 'img/block.png', // картинка для блока
		x : math.random(0, width - 200*del*4), // по горизонтали располагаем его рандомно
		y : dy2, // по высоте используем посчитанное ранее значение
	}));
};

// определим переменную для хранения последнего блока
// последним будет считаться блок, которые последним был перемещен наверх
var oldBlock Block{};

// а вот и функция создания уровня, вы ведь ее уже расскомментировали? Как где? Там где кнопка "Новая игра"
func createLevel(i int) { // аргументом передаем количество блоков для игры
	pl.y = 0; // так как мы создаем уровень сначала, то и игрока поставим в ноль
	pl.x = 0;
	score = 0; // обнулим текущий счет
	for i := 0; i <
	OOP.forInt(i, function () { // запустим цикл по созданию блоков
		createBlock(); // и просто вызовем функцию нужное количество раз
	});
	oldBlock = blocks[len(blocks)-1] // запомним какой блок был создан последним, последний - значит самый верхний (ЭТО ВАЖНО)
};

// как только блок окажется очень сильно внизу, мы перекинем его наверх, чтобы не создавать новых
func rePositionBlock(el *Block) { // тут принимаем, какой именно блок будем перекидывать
	var x = math.random(0, width - 200*del*4), // генерируем рандомно его позицию по горизонтали
			y = oldBlock.y - 500*del - // обращаем внимание на oldBlock, это последний телепортированный наверх блок
					math.random(500*del, 800*del); // а вот тут снова рандом, который прибавится к его высоте
	el.setPosition(point(x, y)); // и перепозиционируем блок наверх
	oldBlock = el; // так как теперь этот бок выше последнего, он сам становится последним (самым высоким)
};

// функция отрисовки всех блоков и проверки столкновения плеера с ними
func drawLevel() {

        // стартуем цикл по блокам
	OOP.forArr(blocks, function (el) {

                // проверим, не оказался ли блок сильно внизу
		if (camera.getPosition().y + height + 2000*del < el.y) { // и если оказался
			rePositionBlock(el); // перепозиционируем его
		}

		el.draw(); // обязательно отрисуем

                // теперь проверка на столкновение с игроком, если столкнулся
		if (pl.isStaticIntersect(el.getStaticBox()) && dy > 0) { // причем при столкновении учитываем, что он должен падать вниз
			if (pl.y+pl.h < el.y+el.h/3) // возьмем нижнюю позицию нашего игрока, и проверим,  выше ли она одной трети от верха нашего блока, чтобы отталкивался он только если ноги выше центра
				dy = -50*del; // установим силу, двигающую объект
		}
	});
};